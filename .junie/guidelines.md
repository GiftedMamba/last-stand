# Project Development Guidelines (Last_Stand)

This document captures project-specific knowledge to speed up development, testing, and troubleshooting for the Last_Stand Unity repository.

Audience: advanced Unity/.NET developers using Rider. Unity version pinned via Rider-generated .csproj hints: 6000.2.2f1.

Project info located under .docs/gamedoc.md; If information in prompt conflicts with this document, use prompt information

ALL SCRIPTS SHOULD BE INSIDE ASSETS/GAME/CODEBASE folder.
DO NOT BUILD SOLUTION INSIDE RIDER
IMPORTANT: ALL SERVICES SHOULD BE INJECTED VIA VCONTAINER THROUGH METHOD WITH INJECT ATTRIBUTE, NOT RESOLVED INSIDE CLASSES!!!

Use assembly definitions for scripts to speed up compilation. At least core, gameplay and UI.

## 1. Build and Configuration

- Unity version: 6000.2.2f1 (verify in ProjectSettings and Rider-generated csproj references). Using a different minor version can break package resolution or URP pipeline compatibility.
- Scripting runtime/Api:
  - TargetFrameworkVersion in generated csproj: v4.7.1 (Unity “.NET Framework”/unity-4.8-api subset for compilation). C# LangVersion is 9.0 via Rider integration.
- Key Packages (Packages/manifest.json):
  - com.unity.test-framework 1.5.1 (NUnit 3 via com.unity.ext.nunit)
  - com.unity.render-pipelines.universal 17.2.0
  - com.unity.inputsystem 1.14.2
  - Rider/VS integration packages included
- Editor/CLI assumptions:
  - Build scripts and csproj are auto-generated by Unity. Do not hand-edit the .csproj files; changes will be overwritten.
  - Library and obj are transient. Avoid committing changes there.

Recommended local setup:
- Install Unity 6000.2.2f1 via Unity Hub.
- Open the project from Unity Hub to let it import packages and regenerate Library.
- Use Rider as the IDE (package com.unity.ide.rider is included). Generate Rider project files from Unity if needed.

Build inside Unity:
- File > Build Settings… select target platform. URP present; ensure graphics settings match pipeline assets.
- For CI headless builds, use Unity Editor CLI with -batchmode -nographics -quit and -projectPath, -buildTarget, and -executeMethod for custom build scripts if you add any.

## 2. Testing

The project already includes the Unity Test Framework (com.unity.test-framework 1.5.1). NUnit is referenced in the Editor assembly (Assembly-CSharp-Editor.csproj shows nunit.framework).

Two common test types:
- EditMode tests: run in the Editor process, fast, good for pure C# logic and minimal engine interaction.
- PlayMode tests: run in a play context; good for scene/behaviour tests.

### Creating a simple EditMode test

Project-specific convention: placing tests under any Assets/**/Editor folder ensures they compile into the Editor assembly where nunit.framework is available.

Example structure:
- Assets/Tests/Editor/SampleEditModeTests.cs

Example contents:

```
using NUnit.Framework;

namespace LastStand.Tests
{
    public class SampleEditModeTests
    {
        [Test]
        public void AddsNumbers()
        {
            Assert.AreEqual(4, 2 + 2);
        }
    }
}
```

Notes:
- No asmdef required for this minimal setup because the Editor .csproj already references NUnit via the Unity Test Framework package. If you prefer assembly definitions, create an Editor-only asmdef and reference "UnityEngine.TestRunner" and "UnityEditor.TestRunner".

### Running tests

Preferred: Unity Test Runner
- Editor GUI: Window > General > Test Runner. Select EditMode tab and Run All.
- CLI (CI/headless):
  - Example (adjust Unity path):
    - Windows: "C:\Program Files\Unity\Hub\Editor\6000.2.2f1\Editor\Unity.exe" -batchmode -projectPath "C:\Repos\GiftedMambaEnt\Last_Stand" -runTests -testPlatform EditMode -logFile - -quit -nographics -testResults "TestResults.xml"
  - Artifacts: JUnit or NUnit XML via -testResults and -resultFiles.

Rider’s Unit Test runner
- Rider can discover NUnit tests from Unity-generated projects (especially Editor tests). If discovery fails, open the project from Unity first to regenerate .csproj and ensure packages are restored.

PlayMode tests
- Place tests in Assets/Tests/PlayMode and reference runtime APIs. Use Test Runner’s PlayMode tab or -testPlatform PlayMode.

### What we verified
- The project references com.unity.test-framework and includes nunit.framework in Assembly-CSharp-Editor.csproj, so Editor-based NUnit tests will compile and run via Unity Test Runner.
- We compiled a minimal EditMode test class locally to ensure the project builds with tests included; to actually execute tests, use Unity’s Test Runner (Editor GUI) or the Unity CLI example above.
- We did not leave sample test files in the repo to keep it clean; follow the example to add your own tests under Assets/Tests/Editor.

## 3. Additional Development Information

Coding style and project specifics:
- Runtime code currently targets UnityEngine API with C# 9 syntax available via Rider. Use modern patterns where it does not affect AOT platforms if targeting IL2CPP later.
- Place editor scripts under an Editor folder to avoid runtime inclusion (Assembly-CSharp-Editor).
- URP: If adding new shaders/materials, ensure the active URP Render Pipeline Asset is assigned in ProjectSettings/Graphics, and quality tiers reference correct pipeline assets.
- Input System: Project includes the new Input System. If you add input actions, remember to generate C# wrappers and enable the Input System in Player Settings (it likely already is when package is present). Avoid mixing with the old Input Manager unless you enable both.

Asset and folder conventions:
- Avoid adding heavy assets to VCS unless necessary. Library/Temp/Logs/obj should remain untracked.
- For scripts that must not be included in player builds, place them beneath an Editor folder or wrap in #if UNITY_EDITOR.

Debugging tips:
- Use [Conditional("UNITY_EDITOR")] logs or the built-in Logger; avoid Debug.Log in performance-sensitive code paths.
- For deterministic tests, avoid using Time.deltaTime in logic under test; inject time providers.

Scenes structure
- Game starts from scene named BootScene.
- Main gameplay scene named Gameplay

## 4. Adding More Tests (Guidelines)
- Prefer EditMode for pure logic; create PlayMode only when engine state or scenes are required.
- If tests need domain reload isolation, mark with [UnitySetUp]/[UnityTearDown] or use [SetUp]/[TearDown] for standard NUnit.
- When creating custom asmdef for tests:
  - Set "Test Assemblies" to true.
  - Add references to "UnityEngine.TestRunner" and "UnityEditor.TestRunner" as needed.
  - Limit platform targets if required.

## 5. CI Hints
- Use Unity Editor CLI to run tests in CI. Cache Library folder between runs to reduce import time.
- Use -nographics in headless environments. Emit XML test results and upload to CI test reporting.

## 6. Known Pitfalls
- Editing .csproj/.sln directly is ephemeral; Unity will overwrite. Use asmdef and Unity settings instead.
- Mismatched Unity versions can cause package resolution errors or compilation errors due to API surface changes.
- If Rider does not discover tests, ensure Unity has generated project files after enabling Test Framework; then reopen in Rider.


IMPORTANT!!! DO NOT USE STATIC METHODS OR EVENTS OUTSIDE LOGGER!!!

## 7. Architecture and codestyle
- Follow C# conventions (PascalCase for types/methods, camelCase for locals/params). Private fields should start with prefix _
- Use C# 9 syntax where possible.
- Order of members: serialied fields, constants, private instance fields ans private static fields, public fields and properties, events, constructors(or injection function), public methods, protected and private last.
- Use wrapper on Unity Logger for logging. It can be static class. But avoid static methods and events in general in game logic. Statics as utility functions are ok.
- Use VContainer for injection of global and scene-level services only
- DO NOT use VContainer for injection of gameobject level componennts. Rely on GetComponent/InChidren instead or direct serialzed references.
- Prefer UniTask over standart tasks.
- For the sake of simplicity do not use addressables, use direct references or load from resources, but use abstraction to easy later migration.
- Use pools when possible and it makes sense.
- Use MVP pattern for UI
- All UI screens should be managed in centralized screen service.
- Use ScriptableObject for settings and shared configurations
- Namespaces should start from Game and reflect folder sturcture, but avoid very deep nesting, no more than 4 levels. Do not include Codebase folder in namespace. For instance Game.UI.Screens; Game.Core;
- Store each feature in separate folder.
- DO NOT use FindObjectOfType.
- Use services which are injected via VContainer to share information between systems and features and components.
- Use SerializableInterface<T> when you need to serialize interface reference in MonoBehaviour or ScriptableObject.
- Ensure all triggres and animator parameters are stored in centralized place and hashed
- Schedule timers or cooldowns for things like abilities or any other gameplay logic in dedicated services, do not use cooldowns inside UI layer for gameplay logic!
- If you register in scopes services, which inherited from Monobehavior, use [SerializedFied] and register them in Container, not from hierarchy.
- Enums should be numbered from 0, always use Unknown = 0 as a first value.
- Do not use velocity of Rigidbody, it is obsolte. Use linearVlocity instead
- If you need to control timescale, use dedicated service for it
- Use Dotween for UI animations
- Use IObjectResolver.Instantiate for creating new objects, not Instantiate to have all dependencies injected.
- Do not use hardcoded strings. Declare constants in class level, or separate class for similar entities, for isntance ScreenNames.cs
- You should NEVER EVER control screen game objects outside screenService. Only ScreenService can show, hide, destroy screens.

## 8. Layering & Ownership

- **Domain (Pure C#):** game rules, calculations, state machines, timers, catalogs. No Unity types except data IDs/enums.
- **Infrastructure:** bridges to Unity (pools, Addressables, audio, VFX, input, persistence, SL registration).
- **Presentation:** MonoBehaviours and UI. Views *observe* Domain; they do not *own* rules.

**Rule:** Views never mutate game rules directly; they dispatch intents to Application/Domain services which validate and act.

## 9. Time, Update, and Scheduling

- **Centralized Tick:** A **GameTimeService** distributes `deltaTime` to domain systems needing deterministic timers (cooldowns, debuffs, wave pacing).
- **No per-object Update storms.** Systems iterate over registered objects (e.g., all active projectiles) via managers.
- **Coroutines allowed only in Infrastructure/Presentation** (spawning, FX lifetimes). Domain uses numeric timers.

## 10. Events & Messages

- **Domain Events** (pure C#)
- Prefer to use readonly structs for events over custom delegates
- **UI subscribes** via Presenters; **audio/VFX** listen through adapters.
- **No UnityEvent in Domain.** Use C# events or an interface-based bus in Domain; adapters translate to UnityEvent/UnityAction only at the edges.
